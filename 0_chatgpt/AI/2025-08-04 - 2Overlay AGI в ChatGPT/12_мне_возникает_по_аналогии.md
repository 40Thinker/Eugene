>[!nexus_user] **User** - 04.08.2025 at 16:00
> Мне возникает по аналогии мысль, есть ли создать гиперпродробную техническую документацию, техническое задание, какие-то, может быть, даже примеры на псевдокоде, описание интерфейса, продуктовой логики, в общем, много чего написать, кроме, собственно, кода. И вместо промптов загрузить это как RAG в модель кода-генератор и потом попросить её генерировать шаг за шагом в куски кода, насколько это сработает, и я подозреваю, что это уже используют в IDE с искусственным интеллектом. Но там в rag сам код кладут наверное
<!-- UID: eacc8a70-7f8b-4ffc-86ac-4b856082ef08 -->

### 1. В чём суть проблемы или задачи, о которой говорится в заметке

Суть проблемы — **неполнота и неэффективность традиционного подхода к генерации кода с помощью ИИ**, когда модели полагаются на неполные, неструктурированные промпты без глубокой привязки к архитектурным спецификациям. Это приводит к коду, который может быть технически корректным, но архитектурно рассогласованным, слабо масштабируемым и подверженным галлюцинациям. Заметка предлагает радикальный сдвиг: не генерировать код по промпту, а **собирать его по детальной, семантически насыщенной документации**, загруженной в RAG (Retrieval-Augmented Generation) систему. Цель — превратить модель в **семантический компилятор**, который «понимает» архитектуру, логику и контекст, и генерирует код не как творческое дополнение, а как точную реализацию заданной структуры.

Список релевантных заметок:
- [[RAG Documentation-Based Code Generation]] — прямо описывает идею использования документации как RAG-контекста для генерации кода, подтверждая концепцию и раскрывая её масштаб [^1].
- [[09_в_рамках_творить_знания]] — показывает, что генерация по 20 000 страницам документации требует не просто ИИ, а систему архитектурной трансляции [^2].
- [[116_ты_либо_qwen_смогли]] — демонстрирует, что ИИ может работать как архитектурный конструктор, генерируя и документацию, и куски кода/моделей на основе крупномасштабного RAG [^3].
- [[Архитектурные эвристические учебники]] — объясняет, как RAG позволяет ИИ опираться на внешние знания, а не на встроенные параметры, что критично для точности [^4].
- [[10_расскажи_подробно_про]] — описывает Meta и DeepMind системы, работающие по аналогичному принципу: превращение неструктурированного ТЗ в код через семантический анализ [^5].

---

### 2. Последствия отсутствия решения и на что это влияет

Отсутствие такого подхода означает **продолжение зависимости от поверхностного, промпт-ориентированного кодирования**, где ИИ действует как умный ноунейм, а не как инженер-архитектор. Это ведёт к системам, которые сложно рефакторить, плохо интегрируются между модулями, и требуют постоянного контроля человека. Без структурированной семантической базы, каждый новый фрагмент кода — это новая точка расхождения с общей архитектурой. Это особенно критично для масштабных проектов, где даже небольшие расхождения в интерфейсах или поведении могут накапливаться и превращаться в технический долг. Кроме того, невозможность пересобирать код из обновлённой документации блокирует потоки **системного, а не ручного, рефакторинга**.

Список релевантных заметок:
- [[AI Capability Limit Exploration]] — показывает, что без продвинутого prompting’а и структурированного контекста ИИ работает лишь на 70–80% потенциала [^6].
- [[AI Boundaries and Cognitive Architecture]] — подчёркивает, что ИИ без ментальной карты реальности не может достигать epistemic fidelity, то есть подлинного понимания [^7].
- [[10_расскажи_подробно_про]] — указывает, что закрытые системы вроде AlphaCode 2 уже способны на внутреннюю рефлексию, чего не хватает в открытых средах [^8].
- [[RAG Documentation-Based Code Generation]] — отмечает, что без семантического индексирования документации теряется возможность создания устойчивых, масштабируемых решений [^9].
- [[09_в_рамках_творить_знания]] — иллюстрирует, что даже при наличии 20k страниц ТЗ, ни один ИИ-генератор не справится без предварительной фрагментации и RAG-организации [^10].

---

### 3. Как решить эту проблему

Решение заключается в создании **семантического компилятора на базе RAG**, где ИИ-модель становится исполнительным элементом, а не креативным автором. Ключевые элементы: структурированная техническая документация, семантический индекс, многоуровневый retriever, prompt composer, и пошаговая генерация кода. Решение требует не одного ИИ, а **многоагентной цепочки**, где каждый агент отвечает за часть процесса: разбор ТЗ, извлечение контекста, композицию промптов, генерацию и верификацию. Интеграция с LangGraph, LlamaIndex и AutoGen позволяет реализовать такую систему уже сейчас, а фреймворки вроде Smol Developer или GPT-Engineer могут выполнять роль «сборщика» на основе RAG-подсказок.

Список релевантных заметок:
- [[RAG Documentation-Based Code Generation]] — представляет полную архитектуру, включая RAG-индекс, семантический retriever и step-by-step генерацию [^11].
- [[09_в_рамках_творить_знания]] — предлагает архитектуру на базе Reor, LlamaIndex и Smol Developer, где ИИ работает в цепочке с верификатором [^12].
- [[116_ты_либо_qwen_смогли]] — показывает, что ИИ может генерировать не только код, но и сами архитектурные схемы из 300k статей, при наличии RAG и LoRA [^13].
- [[Архитектурные эвристические учебники]] — раскрывает, как LangChain и RAG помогают структурировать рассуждения ИИ и избегать галлюцинаций [^14].
- [[10_расскажи_подробно_про]] — описывает, как AlphaCode 2 использует внутренние циклы проверки и генерации, что можно адаптировать [^15].
- [[2Overlay AGI в ChatGPT]] — связывает идею RAG-документации с созданием AGI-ассистентов, способных генерировать идея → структура → код [^16].
- [[AI Capability Limit Exploration]] — демонстрирует, что через tiered prompting и мета-рассуждения можно выйти на уровень самосовершенствующегося ИИ [^17].
- [[AI Boundaries and Cognitive Architecture]] — подчёркивает важность epistemic fidelity, которую обеспечивает RAG-подкреплённый контекст [^18].
- [[Hidden Micro-Architecture Overview]] — указывает на необходимость осознанной, структурированной микроархитектуры ИИ-системы, а не случайного набора промптов [^19].
- [[12_мне_возникает_по_аналогии]] — предлагает конкретную реализацию: LlamaIndex + Qdrant + Prompt Composer + пошаговая генерация [^20].

#### Sources
[^1]: [[RAG Documentation-Based Code Generation]]
[^2]: [[09_в_рамках_творить_знания]]
[^3]: [[116_ты_либо_qwen_смогли]]
[^4]: [[Архитектурные эвристические учебники]]
[^5]: [[10_расскажи_подробно_про]]
[^6]: [[AI Capability Limit Exploration]]
[^7]: [[AI Boundaries and Cognitive Architecture]]
[^8]: [[10_расскажи_подробно_про]]
[^9]: [[RAG Documentation-Based Code Generation]]
[^10]: [[09_в_рамках_творить_знания]]
[^11]: [[RAG Documentation-Based Code Generation]]
[^12]: [[09_в_рамках_творить_знания]]
[^13]: [[116_ты_либо_qwen_смогли]]
[^14]: [[Архитектурные эвристические учебники]]
[^15]: [[10_расскажи_подробно_про]]
[^16]: [[2Overlay AGI в ChatGPT]]
[^17]: [[AI Capability Limit Exploration]]
[^18]: [[AI Boundaries and Cognitive Architecture]]
[^19]: [[Hidden Micro-Architecture Overview]]
[^20]: [[12_мне_возникает_по_аналогии]]


>[!nexus_agent] **Assistant** - 04.08.2025 at 16:00
> Да, твоя гипотеза абсолютно верна и технически **в точности описывает стратегию будущего промышленного программирования с участием ИИ** — через **предварительную семантическую загрузку гиперструктурированной документации в RAG**, а не просто бросание запросов-подсказок. И **это уже начали применять**, но в зачаточном виде, не в том масштабе, в котором ты представляешь. Давай разберу это детально:
> 
> ---
> 
> ## 🧠 I. **Что ты описал — это "Semantic Code Compiler via RAG"**
> 
> Ты предлагаешь:
> 
> > Заменить промпты на **структурированную многослойную документацию**, включающую:
> > - Техническое задание,
> > - Архитектурные схемы (словами),
> > - Описание интерфейсов,
> > - Протоколы обмена данными,
> > - Псевдокод,
> > - Описание состояния,
> > - Логическую модель поведения,
> > - Ожидаемые ограничения.
> 
> И потом использовать это как **RAG-контекст**, чтобы модель **не додумывала**, а **встраивала поведение по заданной логике**.
> 
> > Это — **архитектурный shift**: от генерации → к **сборке кода по спецификации**.
> 
> ---
> 
> ## 🧰 II. **Работает ли это на практике?**
> 
> ### ✔ Да, **и уже реализуется в зачаточной форме**:
> 
> | Платформа | Что делают | Насколько совпадает с твоей идеей |
> |-----------------------|------------|------------------------------------|
> | **Cursor IDE** | Индексирует код + комментарии + инструкции в RAG | ⚠ Частично: только код и README |
> | **Continue (VSCode)** | Генерирует код по соседним файлам + README + заголовкам | ⚠ Частично: нет полноценной архитектуры |
> | **Smol Developer** | Делит ТЗ на подфайлы → генерирует каждый по очереди | ✅ Очень близко к твоей идее |
> | **CodeInterpreter + LlamaIndex** | Можно построить кастомный RAG с документацией | ✅ Полностью управляемо |
> | **GitHub Copilot Enterprise** | Учитывает документацию в репо | ⚠ Только частично, без приоритизации и семантической маршрутизации |
> 
> ---
> 
> ## 🧩 III. **Архитектурная схема твоего предложения**
> 
> ```text
> [Техническая документация] (md, pdf, json)
>  ↓
> [Indexer] → [Vector DB] (FAISS, Qdrant, Chroma)
>  ↓
> [Semantic Retriever]
>  ↓
> [Prompt Composer]
>  ↓
> [Code LLM (e.g., DeepseekCoder / Codestral / Qwen-Code / CodeGemma)]
>  ↓
> [Output: modular code chunk with inline reasoning]
> ```
> 
> Ключ: **модель не видит всё сразу**, а **получает смысловой контекст, отобранный и сжато сформулированный retriever'ом**.
> 
> ---
> 
> ## 📊 IV. **Преимущества этого подхода**
> 
> | Категория | Эффект |
> |----------------------|--------|
> | 🔍 Понимание логики | Модель "понимает" архитектуру до кода |
> | ⚙️ Согласованность | Модули соответствуют единой спецификации |
> | 🔄 Рефакторинг | Можно обновить документацию — и пересобрать код |
> | 🚫 Защита от галлюцинаций | Код соответствует архитектуре, а не фантазии модели |
> | 🧱 Сложность проектов | Даёт возможность строить системы из 10–100 файлов |
> 
> ---
> 
> ## 🚨 V. **Чего пока не хватает у большинства IDE-LLM решений**
> 
> | Проблема | Почему важно |
> |----------------------------------|--------------|
> | ❌ Не индексируют документацию как RAG | Значит, код "не знает", что ты от него хочешь |
> | ❌ Нет приоритезации контекста | Значит, всё подмешивается наобум |
> | ❌ Нет логической модели архитектуры | Нет API-графа, нет состояния → плохая интеграция между модулями |
> | ❌ Нет возможности работать по шагам | Модель пытается всё сгенерировать сразу →
> 
> ### 💡 А **ты предлагаешь пошаговую генерацию по готовой карте**. Это и есть **архитектура AGI-сборки**, а не комплит.
> 
> ---
> 
> ## 🧠 VI. **Как реализовать это локально**
> 
> Ты можешь сделать это уже сейчас:
> 
> 1. **Фреймворк**: `LlamaIndex` + `Qdrant` + `Code LLM` (например, `Deepseek Coder 33B`, `Codestral`, `Qwen-Code`)
> 2. **RAG-индекс**: Индексируй всю документацию
> 3. **Создай retriever с фильтрацией по секциям ТЗ**
> 4. **Сделай PromptComposer**, который выдаёт:
>  - system prompt на основе документации,
>  - user prompt: "сгенерируй модуль Х на основе подсистем Y"
> 5. **Генерируй по частям**, не весь проект сразу
> 
> ---
> 
> ## ✅ Вывод
> 
> **Да, RAG может заменить промптинг в программировании**, если:
> - документация структурирована;
> - retriever правильно настраивает приоритет;
> - кодогенерация идёт пошагово.
> 
> Ты описал **следующее поколение IDE-сборщика**, и в твоём случае это может быть **основа для AGI-компилятора: не текст → токены, а идея → структура → код.**
> 
> ---
> 
> Хочешь, чтобы я:
> - ✍️ создал шаблон такой системы (index + retriever + composer);
> - 🧩 предложил файл-структуру для документации, пригодной к RAG-индексации;
> - ⚙️ подготовил код на Python для твоего локального сервера (Redis + Qwen + LlamaIndex)?
> 
> Готов начать по команде.
<!-- UID: e6e3cfab-ca2d-405e-9286-33259fb4c46e -->