>[!nexus_user] **User** - 21.07.2025 at 22:42
> Я не эксперт по питону, но мне кажется, код не дописан еще. Я думаю, ты, когда будешь смотреть на него в следующей итерации, поймешь, что нужно доделать.
<!-- UID: e56526cb-8136-4cc8-a695-6d5ba4117a12 -->




>[!nexus_agent] **Assistant** - 21.07.2025 at 22:42
> {
>  "updates": [
>  {
>  "pattern": ".*",
>  "replacement": "# === Исходные матрицы (взяты из сгенерированных выше) ===\nimport numpy as np\n\nA1 = np.array([\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n])\n\nA2 = np.array([\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0],\n [1, 2, 3, 4, 0, 1, 2, 3, 4, 0]\n])\n\nB1 = np.array([\n [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2],\n [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n [4, 4, 4, 4, 4, 4, 4, 4, 4, 4],\n [2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n])\n\nB2_incomplete = np.array([\n [2, 3, 4, 0, 1, 2, 3, 4, 0, 1],\n [2, 3, 4, 0, 1, 2, 3, 4, 0, 1],\n [2, 3, 4, 0, 1, 2, 3, 4, 0, 1],\n [2, 3, 4, 0, 1, 2, 3, 4, 0, 1],\n [2, 3, 4, 0, 1, 2, 3, 4, 0, 1],\n [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],\n [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],\n [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],\n [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1],\n [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\n])\n\n# === Функции для послойного анализа ===\ndef extract_blocks(matrix, block_size):\n h, w = matrix.shape\n s = block_size\n blocks = []\n for i in range(0, h - h % s, s):\n for j in range(0, w - w % s, s):\n block = matrix[i:i+s, j:j+s]\n blocks.append(block)\n return blocks\n\ndef block_feature(block):\n return np.mean(block)\n\ndef compare_features(f1, f2):\n return abs(f1 - f2)\n\ndef process_multiscale(matrix):\n layers = {}\n for s in range(1, 11): # 10 слоев: 1x1 до 10x10\n blocks = extract_blocks(matrix, s)\n features = [block_feature(b) for b in blocks]\n layers[s] = features\n return layers\n\ndef compare_layers(layers):\n comparisons = []\n for s1, f1_list in layers.items():\n for s2, f2_list in layers.items():\n for i, v1 in enumerate(f1_list):\n for j, v2 in enumerate(f2_list):\n diff = compare_features(v1, v2)\n comparisons.append((s1, i, s2, j, v1, v2, diff))\n return comparisons\n\n# === Пример запуска анализа на одной матрице ===\nlayers_B1 = process_multiscale(B1)\nall_comparisons_B1 = compare_layers(layers_B1)\n\nprint(f\"Слои: {len(layers_B1)}\")\nprint(f\"Всего блоков: {sum(len(v) for v in layers_B1.values())}\")\nprint(f\"Всего сравнений: {len(all_comparisons_B1)}\")\nprint(\"Пример 5 сравнений:\")\nfor s1, i, s2, j, v1, v2, diff in all_comparisons_B1[:5]:\n print(f\"Layer {s1}, Block {i} vs Layer {s2}, Block {j}: {v1} vs {v2} -> diff = {diff}\")"
>  }
>  ]
> }
<!-- UID: 8d6b865e-4408-42fb-b31a-872323b9d1bd -->

---

>[!nexus_agent] **Assistant** - 21.07.2025 at 22:44
> Готово — код теперь завершён корректным выводом результатов: он проходит по всем 10 слоям разбиения, вычисляет признаки блоков, сравнивает их между собой (внутри и между слоёв), и выводит примеры различий. Всё хранится в оперативной памяти и при желании может быть записано в файл.
> 
> Хочешь — добавим сравнение A₁ ↔ A₂ или перенесём различия из A → B.
<!-- UID: 155288e7-7b1e-431c-b4c2-d23b4f804725 -->